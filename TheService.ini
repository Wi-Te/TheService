[SERVICE]
svcUpdate = \\FS\APLIC\AUTOUPDT\1156\
# опционально. Обновление самого сервиса. Единый источник для всех экземпляров. Если не указано, то сам сервис обновляться не будет
# сервис обновляет себя сам в процессе запуска и работы, но продолжает работать на старой версии до остановки
# для запуска новой версии необходимо перезапустить сервис

description = шаблонный сервис в процессе разработки
# обязательный параметр. описание для консоли services.msc

adusername = xxxxx\xxxxxx
novellname = .xxxxx.xxx.xxxxx.xxxxx
password = xxxxxxxxxxxxxx
# опционально. логин-пароль для запуска службы (adusername), для входа в Novell используется novеllname
# хранятся прямо открыто в этом файле. Сразу после инсталляции сервиса, их отсюда можно удалить
# я в любом случае сохраню себе копию в реестре для последующего входа в новелл (перекодирую в base64)
# для смены логина или пароля: прописать сюда нужные логин/пароль и переустановить сервис (uninstall - install)
# если adusername пустой - то настройка входа для сервиса остается на совести админа # Пользователя для запуска службы можно всегда настроить через services.msc
# если novellname пустой - то я не буду см коннектится к Novell # Реквизиты для автоматического входа в новелл можно настроить в реестре

worklog = svcworks\
# опционально. Каталог, где я буду делать журнал вызова процедур. Журнал будет называться YYYYMM.txt
# файлов будет много! делайте отдельный каталог!!!
# относительный или полный путь

UsesADO = 1
# По умолчанию: да. Сервис будет вызывать CoInitialize / CoUnInitialize для рабочего потока. Делать это в DLL'ке нельзя!
UsesBDE = 1
# По умолчанию: нет. Сервис будет инициализировать / деинициализировать BDE. Делать это самому в DLL'ке - нельзя!

[SERVER]
port = 53760
# опционально. 50000..65535. Если не указано - то сервер не запускается
# адрес+порт должен быть уникальным для каждого сервиса! Номер ПС туда пихайте

#LogMsgHandler = msgproc
# опционально. процедура обработки диагностических сообщений сервера.
# type = procedure(Msg: Cardinal; wParam: WPARAM; lParam: LPARAM); stdcall;

[PAYLOAD]
#updateSrc = D:\TS_TEST\
# опционально. источник обновлений полезной нагрузки
# можно положить инишник для сервиса, но новые настройки будут прочитаны только после перезапуска

dllName = testdll\testdll.dll
# обязательный параметр. наличие длл-ки обязательно
# имя файла, содержащемго все процедуры обработки событий сервиса
# длл-ка, инишка, и екзешник сервиса - все лежать в одном каталоге
# процедуры должны быть stdcall (для совместимости с не дельфийными dll)
# The spelling and case of a function name pointed to by lpProcName must be identical to that in the EXPORTS statement of the source DLL's module
# Importing/exporting DLL functions IS case-sensitive, and always has been. That behavior is tied to the OS DLL loader, which is case-sensitive. That is one of the only areas of the Delphi language that is case-sensitive. This is documented behavior
# Процедура для вызова пользователем без параметрова: function(): Integer; stdcall; (как и для таймеров)
# Проведура для вызова пользователем с параметрами: function(const p: Pointer; sz: Byte): Integer; stdcall; 
# Если пользовательская процедура возвращает 0, то пользователю приходит сообщение, что выполнено успешно
# Если пользовательская процедура возвращает не 0, то считается что она возвращает код ошибки, который будет передан клиенту с сообщением "потрачено"

DllInit = OnInit
# type = procedure(  [function(): Boolean of object; stdcall;]  ); stdcall;
# Обязательно! сервис предоставит функцию (параметр), которую ты должен сохранить в ДЛЛке и дёргать регулярно.
# Если эта функция вернет True, то выполнение любой твоей процедуры обязано тут же завершиться
# Потому что если ты не закроешься добровольно, то я дропну тред принудительно.
# DLL будет выгружаться / загружаться в процессе работы для автообновления, так что организовывай инициализацию/деинициализацию через DLLMain (это будет в потоке Сервиса)
# onDLLinit будет вызван каждый раз после подключения DLL, так что адрес функции у тебя будет (вызван из потока СЕРВИСА)

timers = Timer3; Timer2
# опционально. Строка идентификаторов, разделенных [';', ',', ' ', #9]
# Каждому идентификатору должна соответствовать секция в этом ини-файле

[TIMER1]
sched = 7.30; 7.50; 8.10
nProc = proc1

[TIMER2]
start = 7.30
until = 20.10
every = 0.02
nProc = TimerProc1

[TIMER3]
start = 7.32
until = 20.10
every = 0.01
exact = 1
nProc = TimerProc2

# формат таймера
# время указывается в формате "чч.мм" или "чч:мм" или "чч,мм". От 0,00 до 23,59. 7,90 - валидное число = 8,30
# nProc - обязательно; type = function(): Integer; stdcall; имя процедуры, вызываемой по данному таймеру
# The spelling and case of a function name pointed to by lpProcName must be identical to that in the EXPORTS statement of the source DLL's module
# все остальные параметры опциональны. Но должно быть указано или расписание sched, или start+until+every.
# sched - строка чисел, означающих время запуска задачи, с разделителями. Если указано - все следующие параметры игнорируются
# start - время старта таймера. Время первого запуска в день. Могут быть как "7,30 - 16,10", так и "16,10 - 7,30". В первом случае таймер будет выполняться весь день, во втором - всю ночь.
# until - время окончания таймера. Если таймер выпадает на это время или позже, то он не выполняется;
# every - интервал таймера, every = 0.30, тогда если exact, то старт 10:00 - 10:30 - 11:00; Для интервалов больше 12ч. используйте "shed". Для интервалов больше суток - считайте время сами у себя в ДЛЛ, а таймер вызываейте по расписанию раз в день
# exact - если не указано или = 0, то интервал считается от последнего времени завершения задачи. Если указано и = 1, то интервал считается от времени последнего срабатывания таймера.